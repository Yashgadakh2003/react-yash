---
title: Version 15
description: Upgrade your Next.js Application from Version 14 to 15.
---

{/* The content of this doc is shared between the app and pages router. You can use the `<PagesOnly>Content</PagesOnly>` component to add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. */}

## Upgrading from 14 to 15

To update to Next.js version 15, run the following command using your preferred package manager:

```bash filename="Terminal"
npm i next@rc react@rc react-dom@rc eslint-config-next@rc
```

```bash filename="Terminal"
yarn add next@rc react@rc react-dom@rc eslint-config-next@rc
```

```bash filename="Terminal"
pnpm up next@rc react@rc react-dom@rc eslint-config-next@rc
```

```bash filename="Terminal"
bun add next@rc react@rc react-dom@rc eslint-config-next@rc
```

> **Good to know:**
>
> - If you see a peer dependencies warning, you may need to update `react` and `react-dom` to the suggested versions, or you use the `--force` or `--legacy-peer-deps` flag to ignore the warning. This won't be necessary once both Next.js 15 and React 19 are stable.
> - If you are using TypeScript, you'll need to temporarily override the React types. See the [React 19 RC upgrade guide](https://react.dev/blog/2024/04/25/react-19-upgrade-guide#installing) for more information.

## React 19

- The minimum `react` and `react-dom` is now 19.
- `useFormState` has been replaced by `useActionState`. The `useFormState` hook is still available in React 19, but it is deprecated and will be removed in a future release. `useActionState` is recommended and includes additional properties like reading the `pending` state directly. [Learn more](https://react.dev/reference/react/useActionState).
- `useFormStatus` now includes additional keys like `data`, `method`, and `action`. If you are not using React 19, only the `pending` key is available. [Learn more](https://react.dev/reference/react-dom/hooks/useFormStatus).
- Read more in the [React 19 upgrade guide](https://react.dev/blog/2024/04/25/react-19-upgrade-guide).

## Async Request APIs (Breaking change)

Previously synchronous Dynamic APIs that rely on runtime information are now **asynchronous**:

- [`cookies`](/docs/app/api-reference/functions/cookies)
- [`headers`](/docs/app/api-reference/functions/headers)
- [`draftMode`](/docs/app/api-reference/functions/draft-mode)
- `params` in [`layout.js`](/docs/app/api-reference/file-conventions/layout), [`page.js`](/docs/app/api-reference/file-conventions/page), [`route.js`](/docs/app/api-reference/file-conventions/route), [`default.js`](/docs/app/api-reference/file-conventions/default), [`opengraph-image`](/docs/app/api-reference/file-conventions/metadata/opengraph-image), [`twitter-image`](/docs/app/api-reference/file-conventions/metadata/opengraph-image), [`icon`](/docs/app/api-reference/file-conventions/metadata/app-icons), and [`apple-icon`](/docs/app/api-reference/file-conventions/metadata/app-icons).
- `searchParams` in [`page.js`](/docs/app/api-reference/file-conventions/page)

To ease the burden of migration, a [codemod is available](/docs/app/building-your-application/upgrading/codemods#150) to automate the process and the APIs can temporarily be accessed synchronously.

### `cookies`

```tsx
import { cookies } from 'next/headers'

// Before
const cookieStore = cookies()
const token = cookieStore.get('token')

// After (Preferred usage)
const cookieStore = await cookies()
const token = cookieStore.get('token')

// After (Temporary supported API)
import { type DangerouslyUnwrapCookies } from 'next/headers'
const cookieStore = cookies() as unknown as DangerouslyUnwrapCookies
const token = cookieStore.get('token')
```

```jsx
// Before
const cookieStore = cookies()
const token = cookieStore.get('token')

// After
const cookieStore = await cookies()
const token = cookieStore.get('token')
```

### `headers`

```tsx
import { headers } from 'next/headers'

// Before
const headersList = headers()
const userAgent = headersList.get('user-agent')

// After (Preferred usage)
const headersList = await headers()
const userAgent = headersList.get('user-agent')

// After (Temporary supported API)
import { type DangerouslyUnwrapHeaders } from 'next/headers'
const headersList = headers() as unknown as DangerouslyUnwrapHeaders
const userAgent = headersList.get('user-agent')
```

```jsx
// Before
const headersList = headers()
const userAgent = headersList.get('user-agent')

// After
const headersList = await headers()
const userAgent = headersList.get('user-agent')
```

### `draftMode`

```tsx
import { draftMode } from 'next/headers'

// Before
const { isEnabled } = draftMode()

// After (Preferred usage)
const { isEnabled } = await draftMode()

// After (Temporary supported API)
import { type DangerouslyUnwrapDraftMode } from 'next/headers'
const { isEnabled } = draftMode() as unknown as DangerouslyUnwrapDraftMode
```

```jsx
// Before
const { isEnabled } = draftMode()

// After
const { isEnabled } = await draftMode()
```

### `params`

`layout`

```tsx
// Before
type Params = { slug: string }
export function generateMetadata({ params }: { params: Params }) {
  const slug = params.slug
}
export default function Layout({
  children,
  params,
}: {
  children: React.ReactNode
  params: Params
}) {
  const slug = params.slug
}

// After (Preferred usage)
type Params = Promise<{ slug: string }>
export async function generateMetadata({ params }: { params: Params }) {
  const slug = (await params).slug
}
export default async function Layout({
  children,
  params,
}: {
  children: React.ReactNode
  params: Params
}) {
  const slug = (await params).slug
}

// After (Temporary supported API)
import { type DangerouslyUnwrapParams } from 'next/headers'
type Params = Promise<{ slug: string }>
export async function generateMetadata({ params }: { params: Params }) {
  const syncParams = params as unknown as DangerouslyUnwrapParams<typeof params>
  const slug = syncParams.slug
}
export default async function Layout({
  children,
  params,
}: {
  children: React.ReactNode
  params: Params
}) {
  const syncParams = params as unknown as DangerouslyUnwrapParams<typeof params>
  const slug = syncParams.slug
}
```

```jsx
// Before
export function generateMetadata({ params }) {
  const slug = params.slug
}
export default function Layout({ params }) {
  const slug = params.slug
}

// After
export async function generateMetadata({ params }) {
  const slug = (await params).slug
}
export default async function Layout() {
  const slug = (await params).slug
}

```

`page`

```tsx
// Before
type Params = { slug: string }
export function generateMetadata({ params }: { params: Params }) {
  const slug = params.slug
}
export default function Page({ params }: { params: Params }) {
  const slug = params.slug
}

// After (Preferred usage)
type Params = Promise<{ slug: string }>
export async function generateMetadata({ params }: { params: Params }) {
  const slug = (await params).slug
}
export default async function Page({ params }: { params: Params }) {
  const slug = (await params).slug
}

// After (Temporary supported API)
import { type DangerouslyUnwrapParams } from 'next/headers'
type Params = Promise<{ slug: string }>
export async function generateMetadata({ params }: { params: Params }) {
  const syncParams = params as unknown as DangerouslyUnwrapParams<typeof params>
  const slug = syncParams.slug
}
export default async function Page({ params }: { params: Params }) {
  const syncParams = params as unknown as DangerouslyUnwrapParams<typeof params>
  const slug = syncParams.slug
}
```

```jsx
// Before
export function generateMetadata({ params }) {
  const slug = params.slug
}
export default function Page({ params }) {
  const slug = params.slug
}

// After
export async function generateMetadata({ params }) {
  const slug = (await params).slug
}
export async function Page({ params }) {
  const slug = (await params).slug
}
```

`layout` and `page` (Client Component)

```tsx
'use client'

// Before
type Params = { slug: string }
export default function Page({ params }: { params: Params }) {
  const slug = params.slug
}

// After
import { use } from 'react'
type Params = Promise<{ slug: string }>
export default function Page({ params }: { params: Params }) {
  const slug = use(params).slug
}
```

```jsx
// Before
export default function Page({ params }) {
const slug = params.slug
}

// After
import { use } from "react"
export default function Page({ params }) {
const slug = use(params).slug
}

```

`default`

```tsx
// Before
type Params = { artist: string }
export default function Default({ params }: { params: Params }) {
  const artist = params.artist
}

// After
type Params = Promise<{ artist: string }>
export default async function Default({ params }: { params: Params }) {
  const artist = (await params).artist
}
```

```jsx
// Before
export default function Default({ params }) {
  const artist = params.artist
}

// After
export default async function Default({ params }) {
  const artist = (await params).artist
}

```

`route`

```
// Before
type Params = { slug: string }
export async function GET(request: Request, { params }: { params: Params }) {
  const slug = params.slug
}

// After (Preferred usage)
type Params = Promise<{ slug: string }>
export async function GET(request: Request, { params }: { params: Params }) {
  const slug = (await params).slug
}

// After (Temporary supported API)
import { type DangerouslyUnwrapParams } from "next/headers"
type Params = Promise<{ slug: string }>
export async function GET(request: Request, { params }: { params: Params }) {
  const syncParams = params as unknown as DangerouslyUnwrapParams<typeof params>
  const slug = syncParams.slug
}

```

```
// Before
export async function GET(request, { params }) {
  const slug = params.slug
}

// After
export async function GET(request, { params }) {
  const slug = (await params).slug
}

```

`opengraph-image`, `twitter-image`, `icon` and `apple-icon`

```tsx
// Before
type Params = { slug: string }
export function generateImageMetadata({ params }: { params: Params }) {
  const slug = params.slug
}
export function Image({ params }: { params: Params }) {
  const slug = params.slug
}

// After (Preferred usage)
type Params = Promise<{ slug: string }>
export async function generateImageMetadata({ params }: { params: Params }) {
  const slug = (await params).slug
}
export async function Image({ params }: { params: Params }) {
  const slug = (await params).slug
}

// After (Temporary supported API)
import { type DangerouslyUnwrapParams } from 'next/headers'
type Params = Promise<{ slug: string }>
export async function generateImageMetadata({ params }: { params: Params }) {
  const syncParams = params as unknown as DangerouslyUnwrapParams<typeof params>
  const slug = syncParams.slug
}
export async function Image({ params }: { params: Params }) {
  const syncParams = params as unknown as DangerouslyUnwrapParams<typeof params>
  const slug = syncParams.slug
}
```

```jsx
// Before
export function generateImageMetadata({ params }) {
  const slug = params.slug
}
export function Image({ params }) {
  const slug = params.slug
}

// After
export async function generateImageMetadata({ params }) {
  const slug = (await params).slug
}
export async function Image({ params }) {
  const slug = (await params).slug
}
```

### `searchParams`

`page`

```tsx
// Before
type SearchParams = { [key: string]: string | string[] | undefined }
export function generateMetadata({
  searchParams,
}: {
  searchParams: SearchParams
}) {
  const query = searchParams.query
}
export default function Page({ searchParams }: { searchParams: SearchParams }) {
  const query = searchParams.query
}

// After (Preferred usage)
type SearchParams = Promise<{ [key: string]: string | string[] | undefined }>
export async function generateMetadata({
  searchParams,
}: {
  searchParams: SearchParams
}) {
  const query = (await searchParams).query
}
export async function Page({ searchParams }: { searchParams: SearchParams }) {
  const query = (await searchParams).query
}

// After (Temporary supported API)
import { type DangerouslyUnwrapSearchParams } from 'next/headers'
type SearchParams = Promise<{ [key: string]: string | string[] | undefined }>
export async function generateMetadata({
  searchParams,
}: {
  searchParams: SearchParams
}) {
  const syncSearchParams =
    searchParams as unknown as DangerouslyUnwrapSearchParams<
      typeof searchParams
    >
  const query = syncSearchParams.query
}
export async function Page({ searchParams }: { searchParams: SearchParams }) {
  const syncSearchParams =
    searchParams as unknown as DangerouslyUnwrapSearchParams<
      typeof searchParams
    >
  const query = syncSearchParams.query
}
```

```jsx
// Before
export function generateMetadata({ searchParams }) {
  const query = searchParams.query
}
export default function Page({ searchParams }) {
  const query = searchParams.query
}

// After
export async function generateMetadata({ searchParams }) {
  const query = (await searchParams).query
}
export async function Page({ searchParams }) {
  const query = (await searchParams).query
}
```

`page` (Client Component)

```tsx
'use client'

// Before
type SearchParams = { [key: string]: string | string[] | undefined }
export default function Page({ searchParams }: { searchParams: SearchParams }) {
  const query = searchParams.query
}

// After
import { use } from 'react'
type SearchParams = Promise<{ [key: string]: string | string[] | undefined }>
export default function Page({ searchParams }: { searchParams: SearchParams }) {
  const query = use(searchParams).query
}
```

```jsx
// Before
export default function Page({ searchParams }) {
  const query = searchParams.query
}

// After
export default function Page({ searchParams }) {
  const query = use(searchParams).query
}

```

## `fetch` requests

[`fetch` requests](/docs/app/api-reference/functions/fetch) are no longer cached by default.

To opt specific `fetch` requests into caching, you can pass the `cache: 'force-cache'` option.

```js filename="app/layout.js"
export default async function RootLayout() {
  const a = await fetch('https://...') // Not Cached
  const b = await fetch('https://...', { cache: 'force-cache' }) // Cached

  // ...
}
```

To opt all `fetch` requests in a layout or page into caching, you can use the `export const fetchCache = 'default-cache'` [segment config option](/docs/app/api-reference/file-conventions/route-segment-config). If individual `fetch` requests specify a `cache` option, that will be used instead.

```js filename="app/layout.js"
// Since this is the root layout, all fetch requests in the app
// that don't set their own cache option will be cached.
export const fetchCache = 'default-cache'

export default async function RootLayout() {
  const a = await fetch('https://...') // Cached
  const b = await fetch('https://...', { cache: 'no-store' }) // Not cached

  // ...
}
```

## Route Handlers

`GET` functions in [Route Handlers](/docs/app/api-reference/file-conventions/route) are no longer cached by default. To opt `GET` methods into caching, you can use a [route config option](/docs/app/api-reference/file-conventions/route-segment-config) such as `export const dynamic = 'force-static'` in your Route Handler file.

```js filename="app/api/route.js"
export const dynamic = 'force-static'

export async function GET() {}
```

## Client-side Router Cache

When navigating between pages via `<Link>` or `useRouter`, [page](/docs/app/api-reference/file-conventions/page) segments are no longer reused from the client-side router cache. However, they are still reused during browser backward and forward navigation and for shared layouts.

To opt page segments into caching, you can use the [`staleTimes`](/docs/app/api-reference/next-config-js/staleTimes) config option:

```js filename="next.config.js"
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    staleTimes: {
      dynamic: 30,
      static: 180,
    },
  },
}

module.exports = nextConfig
```

[Layouts](/docs/app/api-reference/file-conventions/layout) and [loading states](/docs/app/api-reference/file-conventions/loading) are still cached and reused on navigation.

## `next/font`

The `@next/font` package has been removed in favor of the built-in [`next/font`](/docs/app/api-reference/components/font). A [codemod is available](/docs/app/building-your-application/upgrading/codemods#built-in-next-font) to safely and automatically rename your imports.

```js filename="app/layout.js"
// Before
import { Inter } from '@next/font/google'

// After
import { Inter } from 'next/font/google'
```

## bundlePagesRouterDependencies

`experimental.bundlePagesExternals` is now stable and renamed to `bundlePagesRouterDependencies`.

```js filename="next.config.js"
/** @type {import('next').NextConfig} */
const nextConfig = {
  // Before
  experimental: {
    bundlePagesExternals: true,
  },

  // After
  bundlePagesRouterDependencies: true,
}

module.exports = nextConfig
```

## serverExternalPackages

`experimental.serverComponentsExternalPackages` is now stable and renamed to `serverExternalPackages`.

```js filename="next.config.js"
/** @type {import('next').NextConfig} */
const nextConfig = {
  // Before
  experimental: {
    serverComponentsExternalPackages: ['package-name'],
  },

  // After
  serverExternalPackages: ['package-name'],
}

module.exports = nextConfig
```

## Speed Insights

Auto instrumentation for Speed Insights was removed in Next.js 15.

To continue using Speed Insights, follow the [Vercel Speed Insights Quickstart](https://vercel.com/docs/speed-insights/quickstart) guide.

## `NextRequest` Geolocation

The `geo` and `ip` properties on `NextRequest` have been removed as these values are provided by your hosting provider. A [codemod](/docs/app/building-your-application/upgrading/codemods#150) is available to automate this migration.

If you are using Vercel, you can alternatively use the `geolocation` and `ipAddress` functions from [`@vercel/functions](https://vercel.com/docs/functions/vercel-functions-package) instead:

```ts filename="middleware.ts"
import { geolocation } from '@vercel/functions'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const { city } = geolocation(request)

  // ...
}
```

```ts filename="middleware.ts"
import { ipAddress } from '@vercel/functions'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const ip = ipAddress(request)

  // ...
}
```
